/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`don_blog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `don_blog`;

/*Table structure for table `category` */

DROP TABLE IF EXISTS `category`;

CREATE TABLE `category` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) DEFAULT NULL COMMENT '文章分类名称',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8 COMMENT='文章分类表';

/*Data for the table `category` */

insert  into `category`(`id`,`name`) values (1,'项目实战');
insert  into `category`(`id`,`name`) values (2,'经验分享');
insert  into `category`(`id`,`name`) values (10,'测试');

/*Table structure for table `draft_post_redis` */

DROP TABLE IF EXISTS `draft_post_redis`;

CREATE TABLE `draft_post_redis` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `redisKey` varchar(100) DEFAULT NULL,
  `postId` int(11) DEFAULT NULL,
  `title` varchar(200) DEFAULT NULL,
  `content` text,
  `categoryId` int(11) DEFAULT NULL,
  `poster` varchar(200) DEFAULT NULL,
  `tags` varchar(200) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `draft_post_redis` */

/*Table structure for table `laboratory` */

DROP TABLE IF EXISTS `laboratory`;

CREATE TABLE `laboratory` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) DEFAULT NULL COMMENT '项目名称',
  `description` varchar(1000) DEFAULT NULL COMMENT '项目说明',
  `link` varchar(500) DEFAULT NULL COMMENT '项目地址',
  `poster` varchar(500) DEFAULT NULL COMMENT '项目海报',
  `createTime` datetime DEFAULT NULL COMMENT '创建时间',
  `github` varchar(500) DEFAULT NULL COMMENT '项目Github地址',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8 COMMENT='实验室表，记录个人项目';

/*Data for the table `laboratory` */

insert  into `laboratory`(`id`,`name`,`description`,`link`,`poster`,`createTime`,`github`) values (12,'GitHub Rank','GitHub Rank是一个基于Vue2.js和Node.js爬虫开发的项目，用于展示不同编程语言的开源项目排行。','http://www.tdon.site/vue-github-rank/','/uploads/20171216/1513398772390.png','2017-12-27 16:37:37','https://github.com/XNAL/vue-github-rank');
insert  into `laboratory`(`id`,`name`,`description`,`link`,`poster`,`createTime`,`github`) values (13,'ReadMore','ReadMore是一个基于Vue2.js全家桶开发的读书网站，数据来源于追书神器。','http://www.tdon.site/read-more/','/uploads/20171216/1513398474244.png','2017-12-27 16:38:19','https://github.com/XNAL/ReadMore');

/*Table structure for table `post` */

DROP TABLE IF EXISTS `post`;

CREATE TABLE `post` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(200) DEFAULT NULL COMMENT '文章标题',
  `content` text COMMENT '文章内容',
  `categoryId` int(11) DEFAULT NULL COMMENT '文章分类表主键',
  `status` enum('DRAFT','PUBLISHED','OFFLINE') DEFAULT NULL COMMENT '文章状态(DRAFT: 草稿， PUBLISHED: 发布，OFFLINE: 下线)',
  `poster` varchar(200) DEFAULT NULL COMMENT '海报图片',
  `createTime` datetime DEFAULT NULL COMMENT '创建时间',
  `viewTotal` int(11) DEFAULT NULL COMMENT '文章查看次数',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=26 DEFAULT CHARSET=utf8 COMMENT='文章表';

/*Data for the table `post` */

insert  into `post`(`id`,`title`,`content`,`categoryId`,`status`,`poster`,`createTime`,`viewTotal`) values (1,'基于Vue2开发的读书WebAPP','\n## 前言\n\n初学vue.js，官网的文档写的很清楚，看着不难。俗话说：光说不练假把式。程序猿学个新东西还是要敲出来看看效果比较好。最开始是想搞个音乐类的，毕竟天天都会听歌，但发现搞音乐类的太多了，我再搞个多没意思。考虑了一下，还是搞个看书的吧，这个还是很少有人搞的。找了找发现只有追书神器的api暴露出来了，起点之类的api找不到。最终效果因为api数据的限制，参考了起点中文网app、起点中文网web端，以及追书神器web端，再加上自己的一些想法搞出来的。项目中的小图标使用的是[阿里巴巴的矢量图标库Iconfont](http://www.iconfont.cn/)。\n\n## 技术栈\nvue2 + vuex + vue-router + webpack + ES6 + axios + sass\n\n## 源码地址\n[https://github.com/XNAL/ReadMore](https://github.com/XNAL/ReadMore) \n\n\n<!-- more --> \n## 项目运行\n    \n> git clone https://github.com/XNAL/ReadMore\n\n\n> cd ReadMore\n\n\n> npm install\n\n> npm run dev（本地运行 访问：http://localhost:8080）\n\n> npm run build （部署上线 生成的dist文件夹放到服务器中即可：需要配置代理，如使用nginx，可参考下面问题中的配置）\n\n## 说明\n\n> - 目前只做了第一个版本，还存在一些需要进行优化的细节问题，后续会继续进行维护更新。如果发现什么问题，也欢迎跟我联系反馈。\n> - 如果觉得做的还行，对您有所帮助，欢迎“start”一下。\n\n\n## 开发中遇到的一些问题\n\n\n- ### 多个子组件循环，父组件如何处理加载状态（精选页面）\n\n```\n每个子组件加载完后是同`this.$emit`通知父组件，父组件判断所有子组件加载完成后隐藏loading。\n```\n\n- ### 跳转页面后active标记\n\n```\n最开始使用url.indexOf来处理，后来直接发现vue-router的exact属性更好用。\n```\n    \n- ### 调用第三方api接口时跨域的问题\n\n```\n1. 本地使用proxyTbale\n\n	在config/index.js中添加配置：\n	\n	\'/api\': {\n		target: \'http://api.zhuishushenqi.com\',\n		changeOrigin: true,\n		pathRewrite: {                \n		  \'^/api\': \'\'\n		}   \n	}\n	\n\n2. 部署服务器后通过nginx代理\n\n	nginx中配置：\n	\n	location /api/ {\n		 proxy_pass http://api.zhuishushenqi.com/;\n	 }\n\n3. 调用接口时只需要以`/api`开头就可以\n```\n        \n- ### 服务器部署后vue-router的虚拟路由在刷新时出现404页面\n\n```\n修改nginx配置：\n\nlocation / {\n	 try_files $uri $uri/ @router;          //增加的内容\n	 root /home/don/book;\n	 index index.html;\n}\n \nlocation @router {                          //增加的内容\n	rewrite ^.*$ /index.html last;          //增加的内容\n}                                           //增加的内容\n```\n\n## 访问地址\n\n> [请访问地址：http://www.tdon.site/read-more/](http://www.tdon.site/read-more/)（pc端请用chrome手机模式预览）\n\n> 扫描下面的二维码\n\n> ![二维码](http://p1hywzeee.bkt.clouddn.com/read-more/qrcode.png)\n\n\n## 部分截图\n\n\n- ### 我的书架\n\n![我的书架](/images/readmore/shelf-01.png)\n\n\n![我的书架](/images/readmore/shelf-01.png)\n\n- ### 精选\n\n\n![精选](/images/readmore/featured.png)\n\n- ### 分类\n\n![分类](/images/readmore/category.png)![分类列表](/images/readmore/category-02.png)\n\n![分类列表](/images/readmore/category-03.png)\n\n- ### 排行\n\n![排行](/images/readmore/rank.png)\n\n- ### 书籍详情\n\n![书籍详情](/images/readmore/book.png)\n\n- ### 看书\n\n![看书](/images/readmore/read-01.png) ![看书](/images/readmore/read-02.png)\n\n![看书](/images/readmore/read-03.png) ![看书](/images/readmore/read-04.png)\n\n- ### 搜索\n\n![搜索](/images/readmore/search.png) ![搜索](/images/readmore/search-02.png)',1,'PUBLISHED','','2017-07-30 01:44:43',45);
insert  into `post`(`id`,`title`,`content`,`categoryId`,`status`,`poster`,`createTime`,`viewTotal`) values (2,'Vue.js弹出模态框组件开发','## 前言\r\n\r\n在开发项目的过程中，经常会需要开发一些弹出框效果，但原生的alert和confirm往往都无法满足项目的要求。这次在开发{% post_link 基于Vue2开发的读书WebAPP %}的时候总共有两处需要进行提示的地方，因为一开始就没有引入其他的组件库，现在只好自己写一个模态框组件了。目前只是一个仅满足当前项目需求的初始版本，因为这个项目比较简单，也就没有保留很多的扩展功能。这个组件还是有很多扩展空间的，可以增加更多的自定义内容和样式。这里只介绍如何去开发一个模态框组件，有需要进行更多扩展的，可以根据自己的需求自行开发。\r\n\r\n## 组件模板\r\n\r\n <!-- more -->\r\n\r\n```\r\n<template>\r\n<div class=\"dialog\">\r\n	<div class=\"mask\"></div>\r\n	<div class=\"dialog-content\">\r\n		<h3 class=\"title\">{{ modal.title }}</h3>\r\n		<p class=\"text\">{{ modal.text }}</p>\r\n		<div class=\"btn-group\">\r\n			<div class=\"btn\" @click=\"cancel\">{{ modal.cancelButtonText }}</div>\r\n			<div class=\"btn\" @click=\"submit\">{{ modal.confirmButtonText }}</div>\r\n		</div>\r\n	</div>\r\n</div>\r\n</template>\r\n```\r\n\r\n模态框结构分为：头部标题、提示内容和操作区域。同时一般还会有一个遮罩层。此次需求比较简单，也无需图标等内容，所以结构上写的也比较简单。实际开发中可根据需求对结构进行相应的调整。\r\n\r\n\r\n## 组件样式\r\n\r\n```\r\n.dialog {\r\n	position: relative;\r\n\r\n    .dialog-content {\r\n        position: fixed;\r\n        box-sizing: border-box;\r\n        padding: 20px;\r\n        width: 80%;\r\n        min-height: 140px;\r\n        left: 50%;\r\n        top: 50%;\r\n        transform: translate(-50%, -50%);\r\n        border-radius: 5px;\r\n        background: #fff;\r\n        z-index: 50002;\r\n        .title {\r\n            font-size: 16px;\r\n            font-weight: 600;\r\n            line-height: 30px;\r\n        }\r\n        .text {\r\n            font-size: 14px;\r\n            line-height: 30px;\r\n            color: #555;\r\n        }\r\n        .btn-group {\r\n            display: flex;\r\n            position: absolute;\r\n            right: 0;\r\n            bottom: 10px;\r\n            .btn {\r\n                padding: 10px 20px;\r\n                font-size: 14px;\r\n                &:last-child {\r\n                    color: #76D49B;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    .mask {\r\n        position: fixed;\r\n        top: 0;\r\n        left: 0;\r\n        bottom: 0;\r\n        right: 0;\r\n        z-index: 50001;\r\n        background: rgba(0,0,0,.5);\r\n    }\r\n}\r\n```\r\n样式比较简单，就不多说了。\r\n\r\n## 组件接口\r\n\r\n```\r\nexport default {\r\n	name: \'dialog\',\r\n	props: {\r\n		dialogOption: Object\r\n	},\r\n	data() {\r\n		return {\r\n			resolve: \'\',\r\n			reject: \'\',\r\n			promise: \'\', // 保存promise对象\r\n		}\r\n	},\r\n	computed: {\r\n		modal: function() {\r\n			let options = this.dialogOption;\r\n			return {\r\n				title: options.title || \'提示\',\r\n				text: options.text,\r\n				cancelButtonText: options.cancelButtonText ? options.cancelButtonText : \'取消\',\r\n				confirmButtonText: options.confirmButtonText ? options.confirmButtonText : \'确定\',\r\n			}\r\n		}\r\n	},\r\n	methods: {\r\n		//确定,将promise断定为完成态\r\n		submit() {\r\n			this.resolve(\'submit\');\r\n		},\r\n		// 取消,将promise断定为reject状态\r\n		cancel() {\r\n			this.reject(\'cancel\');\r\n		},\r\n		//显示confirm弹出,并创建promise对象，给父组件调用\r\n		confirm() {\r\n			this.promise = new Promise((resolve, reject) => {\r\n				this.resolve = resolve;\r\n				this.reject = reject;\r\n			});\r\n			return this.promise; //返回promise对象,给父级组件调用\r\n		}\r\n	}\r\n\r\n}\r\n```\r\n在模态框组件中定义了三个方法，核心的方法是`confirm`，此方法是提供给父级组件调用的，返回一个`promise`对象。使用`promise`对象主要是为了异步调用，因为很多时候我们使用模态框时需要根据返回结果再进行下一步处理。\r\n\r\n### 扩展提示\r\n\r\n> 如果需要扩展的话，可以通过`props`的`dialogOption`传递更多的字段，在`computed`中进行判断，比如增加一个字段`isShowCancelButton`可以控制取消按钮是否显示。其他扩展同理。\r\n\r\n\r\n\r\n## 调用\r\n\r\n```\r\n<v-dialog v-show=\"showDialog\" :dialog-option=\"dialogOption\" ref=\"dialog\"></v-dialog>\r\n\r\nthis.showDialog = true;\r\nthis.$refs.dialog.confirm().then(() => {\r\n    this.showDialog = false;\r\n    next();\r\n}).catch(() => {\r\n    this.showDialog = false;\r\n    next();\r\n})   \r\n```\r\n\r\n## 源码地址\r\n\r\n[Dialog组件源码](https://github.com/XNAL/ReadMore/blob/master/src/components/Dialog.vue)\r\n\r\n## 实现效果\r\n![图片描述](/images/dialog/dialog.gif) ![图片描述](/images/dialog/dialog2.gif)\r\n\r\n',2,'PUBLISHED','','2017-07-30 12:39:23',21);
insert  into `post`(`id`,`title`,`content`,`categoryId`,`status`,`poster`,`createTime`,`viewTotal`) values (3,'使用Socket.IO开发五子棋对战','\n## 前言\n\n公司开发微信小程序的项目中需要用的Socket.IO，所以自己先写个简单的项目来练练手，熟悉下Socket.IO。Socket.IO主要用于浏览器和服务器之间的实时通信。对HTML5中websocket进行了封装。具体的就不多说，有兴趣的话可以去[官网](https://socket.io/)看下。\n\n## 技术栈\n\nNode.js + Socket.IO + JS + Canvas\n\n <!-- more -->\n\n## 源码地址\n\n[https://github.com/XNAL/socketio-gobang](https://github.com/XNAL/socketio-gobang)\n\n## 项目运行\n    \n    git clone https://github.com/XNAL/socketio-gobang\n    cd socketio-gobang\n    npm install\n    \n    node socketServer\n    \n    使用浏览器打开/public下的index.html文件即可\n    \n## 说明\n\n1. 此项目只是简单的实现了对战的功能，项目的页面效果写的也比较水（也就能看...），此次项目的重点也不在于页面的效果。\n\n2. 需要同时至少运行两个页面才可以开始游戏，有兴趣的可以自己做下人机对战的功能。 \n\n## 项目截图\n\n![图片描述](/images/gobang/gobang.png) \n\n\n',1,'PUBLISHED',NULL,'2017-09-09 14:59:00',28);
insert  into `post`(`id`,`title`,`content`,`categoryId`,`status`,`poster`,`createTime`,`viewTotal`) values (4,'使用Node.js开发一个小爬虫','## 前言\n\n很多程序猿在最开始学习开发的时候应该都有一个想要自己开发一个爬虫的想法（至少我是有的）。所以国内网络上也是爬虫盛行！学了Node.js之后发现比较适合写爬虫，不过一直没有动手去写，正好这段时间比较闲，就写个爬虫玩下。\n\n想着爬个什么东西呢？正好都比较喜欢看电影，那就从时光网爬下国内的票房排行榜吧。\n\n## Talk is cheap. Show me the code\n\n[不bb，代码在此](https://github.com/XNAL/node-MovieSpider)\n\n <!-- more -->\n\n## 如何\"食用\"\n\n    git clone https://github.com/XNAL/node-MovieSpider\n    \n    cd node-MovieSpider \n\n    npm init\n\n    node index.js\n\n## 搭建环境\n\n- 开发语言：[node.js](https://nodejs.org/en/)\n- 发出http请求：[superagent](http://visionmedia.github.io/superagent/)\n- 并发控制：[async](https://caolan.github.io/async/)\n- 分析网页内容：[cheerio](https://github.com/cheeriojs/cheerio)\n\n## 开始撸代码\n\n### 1. 代码主体\n\n作为一个简单的示例，此次就不开启node服务了，我这里就直接来个自执行的方法。如果有需要，可以根据自己的需求扩展。\n\n    // 启动时直接执行代码 \n    (function spider() {\n        util.fetch_data_get(reqUrl, reqParams)\n            .then((result) => {\n                // 根据页面结构获取总的页数，然后再分页获取数据\n                let $ = cheerio.load(result.body.html);\n                let pageTotal = $(\'.bocontent .pagesize a:last-child\').data(\'page\') || 0;\n                console.log(\'电影数据总页数：\', pageTotal);\n                return pageTotal;\n            })\n            .then((pageTotal) => {\n                // 分页获取数据\n                getMovieData(0, pageTotal);\n            })\n            .catch((err) => {\n                console.log(\'获取链接失败：\', err);\n            })\n    })();\n\n### 2. 发送请求\n\n因为代码中需要多次发送http请求，所以把http请求写成一个公共方法会比较好。使用上面提到`superagent`库来实现。\n\n    // 公共方法：通过get请求获取数据\n    function fetch_data_get(url, queryParams) {\n        return new Promise((reslove, reject) => {\n            superagent\n                .get(url)\n                .set(setting.header)\n                .query(queryParams)\n                .end((err, result) => {\n                    err ? reject(err) : reslove(result);\n                })\n        })\n    }\n\n### 3. 分析目标网站api\n\n根据人工操作得来的api`http://movie.mtime.com/boxoffice/?year=2017&area=china&type=MovieRankingYear&category=all&page=0&display=list&timestamp=1505818638620&version=07bb781100018dd58eafc3b35d42686804c6df8d&dataType=json`可以得到以下参数：\n\n    // 根据网站api得到相应的url和参数\n    const reqUrl = \'http://movie.mtime.com/boxoffice/\';\n    const reqParams = {\n        \'year\': 2017,\n        \'area\': \'china\',\n        \'type\': \'MovieRankingYear\',\n        \'category\': \'all\',\n        \'page\': 0,\n        \'display\': \'list\',\n        \'timestamp\': 1501576013654,\n        \'version\': \'07bb781100018dd58eafc3b35d42686804c6df8d\',\n        \'dataType\': \'json\'\n    };\n\n因为此次要获取的是`2017年内地票房排行榜`。根据分析可知：需要变动的主要是`page`参数，那这里就需要根据页面返回的内容来取得总的`page`。\n\n### 4. 使用cheerio获取所需参数\n\napi返回的页面内容可查看：[将api获取的数据格式化后的页面代码](https://github.com/XNAL/node-MovieSpider/blob/master/time.html)。\n\n这里需要用到`cheerio`来取页码总数的代码，`cheerio`可以理解为服务器端的jQuery，用法也类似：\n\n    // 根据页面结构获取总的页数，然后再分页获取数据\n    let $ = cheerio.load(result.body.html);\n    let pageTotal = $(\'.bocontent .pagesize a:last-child\').data(\'page\') || 0;\n\n### 5. 开始分页取目标数据\n\n<1> 调用上面所说的公共方法`fetch_data_get`获取数据，然后取页面内容，图片地址都先保存在`movieImgs`中，最后再统一下载图片：\n\n	// 根据页面结构获取所需数据\n    let $ = cheerio.load(result.body.html);\n    $(\'.bocontent .boxofficelist dd\').each((idx, elem) => {\n        $(elem).find(\'div.movietopmod\').each((i, el) => {\n            let _this = $(el);\n            let arrLeadActor = [];\n            _this.find(\'.txtbox b p\').eq(1).find(\'a\').each((idx, ela) => {\n                arrLeadActor.push($(ela).text());\n            })\n            movieData.push({\n                rank: _this.find(\'.picbox i\').text(),\n                img: _this.find(\'.picbox img\').attr(\'src\').replace(/\\/u\\//, \"\"),\n                name: _this.find(\'.txtbox h3\').text(),\n                director: _this.find(\'.txtbox b p\').eq(0).find(\'a\').text(),\n                leadActor: arrLeadActor.join(\',\'),\n                point: _this.find(\'.gradebox .point\').text(),\n                total: _this.find(\'.totalbox .totalnum\').text()\n            }),\n            movieImgs.push(_this.find(\'.picbox img\').attr(\'src\').replace(/\\/u\\//, \"\"));\n        })\n    })\n\n<2> 根据页码循环取数据\n\n    if(pageIndex <= pageTotal) {\n        // 设置timeout防止网站反爬虫\n        setTimeout(() => {\n            pageIndex ++;\n            getMovieData(pageIndex, pageTotal);\n        }, setting.timeout);\n    } \n\n<3> 全部数据取出后存储数据，并下载图片。\n\n因为只是一个简单的示例，所以此次数据只是保存到`json`文件中。如果需要对数据进行后续操作的话，那就最好保存到数据库中：\n\n    fs.writeFile(dataDir + reqParams.year + \'.json\', JSON.stringify(movieData), (err) => {\n        if (err) {\n            console.log(err);\n        } else {\n            console.log(\'数据写入成功\');\n        }\n    });\n\n调用下载图片的方法：\n\n    let folderName = imgPrefix + reqParams.year;\n    util.downloadImg(movieImgs, folderName);\n\n`util.js`中的`downloadImg`方法：这里就需要用到上面所说的`async`，使用`async`是为了进行并发控制，不然极短时间发送至少几十几百次的请求，这种情况弄不好就被网站的发爬虫程序给封了，而且大量并发也会导致出错的概率更高。\n\n    // 异步下载图片\n    function downloadImg(urls, folderName) {\n        async.mapLimit(urls, setting.asyncNum, (img, callback) => {\n            fetch_data_get(img, {})\n                .then((result) => {\n                    let fileName = path.basename(img);\n                    let folder = imgDir + folderName;\n                    if(!fs.existsSync(folder)) {\n                        fs.mkdirSync(folder);\n                    }\n                    fs.writeFile(folder + \'/\' + fileName, result.body, (err) => {\n                        if (err) {\n                            console.log(img, \'图片写入失败：\', err);\n                        } else {\n                            console.log(img, \'图片写入成功\');\n                            callback(null , fileName);\n                        }\n                    })\n                })\n                .catch((err) => console.log(err))\n        }, (err, result) => {\n            if (err) {\n                console.log(\'图片下载失败：\', err)\n            } else {\n                console.log(result);\n            }\n        })\n    }\n\n## 结语\n\n到此为止一个简单的Node.js版的小爬虫就开发完成了。其实弄懂了爬虫的原理，再回过头去看，发现开发一个简单的爬虫来说还是很容易的。\n\n最后，欢迎大家去[我的github](https://github.com/XNAL)进行`star`和`fork`。',1,'PUBLISHED',NULL,'2017-09-20 00:04:02',37);
insert  into `post`(`id`,`title`,`content`,`categoryId`,`status`,`poster`,`createTime`,`viewTotal`) values (5,'Vue.js + Node.js爬虫开发一个GitHub排行榜','## 前言\n\n之前[使用Node.js开发一个小爬虫](https://github.com/XNAL/node-MovieSpider)，算是初步对爬虫有了一定的了解，但爬取的数据没什么意义。最近使用GitHub的频率比较高，所以准备爬取一些GitHub的数据玩下。目前爬取了中国区followers排名前100的大神，以及各个编程语言stars大于1000的开源项目。\n\n## 源码\n\n[Talk is cheap. Show me the code.](https://github.com/XNAL/vue-github-rank)\n\n## 访问地址\n\n- [访问地址：http://www.tdon.site/vue-github-rank/](http://www.tdon.site/vue-github-rank/)（pc端开启手机模式浏览效果更佳）\n\n <!-- more -->\n\n- 扫描二维码\n\n![二维码](http://p1hywzeee.bkt.clouddn.com/vue-github-rank/qrcode.png)\n\n## 如何使用\n\n    git clone https://github.com/XNAL/vue-github-rank\n    \n    // 需要先安装mysql，并创建数据库，可参考源码中的`github_rank.sql`\n    \n    cd vue-github-rank\n    npm init\n    \n    // 启动node服务\n    gulp nodemon \n    \n    // 本地运行需另开一个终端框口并执行以下命令，然后访问`http://localhost:8080/`\n    npm run dev\n    \n## 技术栈\n\n- [Vue.js](https://cn.vuejs.org/)： 前端页面展示。\n- [axios](https://github.com/axios/axios): vue官方推荐HTTP库，请求后端数据。\n- [阿里巴巴的矢量图标库Iconfont](http://www.iconfont.cn/): 页面图标，个人项目中使用起来比较方便。\n- [Node.js](https://nodejs.org/en/) + [Koa2](http://koajs.com/)： 后台服务器搭架，（Koa2需要node v7.6以上）。\n- ES6/ES7： 后台开发以ES6语法为主，并使用了ES7中的`async/await`。\n- [gulp](https://gulpjs.com/)： 后台服务器使用，自动化构建工具。\n- [webpack](https://webpack.js.org/)： vue-cli自带的。需要配置本地代理`proxyTable`，以及配置`SCSS`的相关loader。\n- MySql: 数据保存。\n- [superagent](http://visionmedia.github.io/superagent/): 比node.js原生http模块更好用的客户端请求代理模块。\n- [cheerio](https://github.com/cheeriojs/cheerio)：服务端jQuery，分析网页内容。\n- [node-schedule](https://github.com/node-schedule/node-schedule): node.js定时执行模块。\n\n## 说明\n\n1. 关于爬虫爬取数据的说明：目前是每2个小时去Github官网爬取数据，取到的数据会存入数据库中。在爬取的过程中可能会出现单个页面一直无法取到数据的情况，为避免程序一直卡在此步骤，目前是单个页面数据循环请求50次，如果仍取不到数据则跳过此项数据的爬取，等待下一次再进行爬取。\n\n2. 数据库字符集需要设置为`utf8mb4`，因为需要存取emoji表情。\n\n## 项目截图\n\n### 关于（首页）\n\n![关于（首页）](/images/vue-github-rank/about.png)\n\n\n### 中国区前100大神\n\n![中国区前100大神](/images/vue-github-rank/china.png)\n\n### 目录\n\n![目录](/images/vue-github-rank/menu.png)\n\n### 项目\n\n![项目](/images/vue-github-rank/project.png)',1,'PUBLISHED',NULL,'2017-10-09 20:46:39',32);
insert  into `post`(`id`,`title`,`content`,`categoryId`,`status`,`poster`,`createTime`,`viewTotal`) values (6,'一个域名下多个Vue.js项目的nginx配置','## 前言\n这段时间又开发了一个[Vue.js+Node.js爬虫开发一个Github排行榜](https://github.com/XNAL/vue-github-rank)的项目，加上之前的[基于Vue2开发的读书WebAPP](https://github.com/XNAL/ReadMore)就有两个vue.js的项目需要部署了。虽然我有两个域名，但是我还是只想在一个域名下配置多个项目。对nginx不是很熟，花费了很长的时间才最终配置出想达到的效果。这里就记录一下如何配置。\n\n## 实现效果\n\n> [http://www.qdnote.com/](http://www.qdnote.com/): 基于Vue2开发的读书WebAPP\n\n> [http://www.qdnote.com/vue-github-rank/](http://www.qdnote.com/vue-github-rank/): vue.js+node.js爬虫开发一个Github排行榜\n\n <!-- more -->\n\n## vue.js配置\n\n> #### 1. config/index.js\n    \n    修改 assetsPublicPath: \'/vue-github-rank/\'\n    \n![config](/images/vue-github-rank/config.png)\n\n> #### 2. src/router/index.js文件修改\n\n    添加 base: \'/vue-github-rank/\'\n    \n![router](/images/vue-github-rank/router.png)  \n\n    \n## nginx配置\n\n![nginx](/images/vue-github-rank/nginx.png)\n\n',2,'PUBLISHED',NULL,'2017-10-13 22:44:08',36);
insert  into `post`(`id`,`title`,`content`,`categoryId`,`status`,`poster`,`createTime`,`viewTotal`) values (7,'微信小程序通讯录demo','## 前言\r\n\r\n帮别人做的一个展示用的demo，最开始只需要一些假数据展示看看效果。不过到最后也没用上，所以就拿出来分享一下吧。我自己把后台接口部分给简单补齐了，做了一些假数据，样式也做了一些调整。因为接口需要https以及上线需要微信审核之类的，所以目前此demo只能在本地查看。同时功能也不是很完善，很多功能做的也比较简陋。如果是初学微信小程序的话，可以参考着看看。\r\n\r\n## 源码\r\n\r\n[Talk is cheap. Show me the code.](https://github.com/XNAL/WxContacts)\r\n\r\n<!-- more -->\r\n## 如何使用\r\n\r\n    git clone https://github.com/XNAL/WxContacts\r\n    \r\n    // 需要先安装mysql，并创建数据库，可参考源码中的`wx_contacts.sql`\r\n    \r\n    cd WxContacts\r\n    npm init\r\n    \r\n    // 启动后台服务接口\r\n    node api/app.js\r\n    \r\n    // 使用微信web开发者工具打开本项目，并通过编译查看效果\r\n    // 登录账号密码可使用以下两个，亦可在数据库中查看：\r\n       手机号：13288886666/15688886666\r\n       密码： 123456\r\n            \r\n## 项目截图\r\n\r\n### 登录\r\n\r\n![登录](/images/WxContacts/wx-login.png)\r\n\r\n### 部门\r\n\r\n![部门](/images/WxContacts/wx-dept.png)\r\n\r\n### 联系人列表\r\n\r\n![联系人列表](/images/WxContacts/wx-card.png)\r\n\r\n### 学科\r\n\r\n![学科](/images/WxContacts/wx-subject.png)\r\n\r\n### 我\r\n\r\n![我](/images/WxContacts/wx-user.png)\r\n',1,'PUBLISHED',NULL,'2017-10-29 21:12:40',38);
insert  into `post`(`id`,`title`,`content`,`categoryId`,`status`,`poster`,`createTime`,`viewTotal`) values (14,'Vue.js和微信小程序路由（页面）跳转拦截','## 前言\n\n在开发有登录功能的项目时，不可避免的需要在路由（页面）跳转时对当前用户的权限进行一定的校验。目前我使用的比较多的Vue.js提供了比较好的解决方案。在开发微信小程序时，发现官方目前并未提供相应的解决方案，根据以往的经验自己实现了路由（页面）跳转拦截。在此对两者做一个简单的对比。\n\n## Vue.js的路由拦截\n\nVue.js官方称之为[导航守卫](https://router.vuejs.org/zh-cn/advanced/navigation-guards.html)。官方文档很详细，使用起来也比较简单，此处就不多说了，简单的示例代码如下：\n<!-- more -->\n    // routes/index.js\n    const router = new Router({\n        routes: [{\n                path: \'/\',\n                name: \'Login\',\n                component: Login\n            },\n            {\n                path: \'/user\',\n                name: \'User\',\n                component: User,\n                meta: {\n                    requireAuth: true\n                }\n            }]\n    });\n    \n    // 全局导航钩子\n    router.beforeEach((to, from, next) => {\n        // meta.requireAuth为true时才进行校验\n        if (to.meta.requireAuth) {\n            // 此处使用vuex进行校验，具体根据业务需求来\n            store.dispatch(\'checkAuth\');\n            if (!store.state.checkAuth) {\n                // rediect是为了登录后重定向到当前页面\n                next({\n                    path: \'/\',\n                    query: {\n                        redirect: to.fullPath\n                    }\n                });\n            } else {\n                next();\n            }\n        } else {\n            next();\n        }\n    });\n\n## 微信小程序的路由拦截\n\n因为微信小程序官方并没有提供官方的解决方案，所以这里只能自己去实现一个。如果对node.js比较熟悉的话，应该对express/koa框架中的经常提到的中间件概念比较熟悉，这里就使用中间件的机制来处理。结合小程序中[Page()函数](https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/page.html)和生命周期，具体代码如下：\n\n    // utils/filter.js\n    function loginCheck(pageObj) {\n    	if (pageObj.onLoad) {\n    		let _onLoad = pageObj.onLoad;\n    		// 使用onLoad的话需要传递options\n    		pageObj.onLoad = function (options) {\n    			if(wx.getStorageSync(\'USERID\')) {\n    				// 获取当前页面\n    				let currentInstance = getPageInstance();\n    				_onLoad.call(currentInstance, options);\n    \n    			} else {\n    				//跳转到登录页\n    				wx.redirectTo({\n    					url: \"/pages/login/login\"\n    				});\n    			}\n    		}\n    	}\n    	return pageObj;\n    }\n\n    // 获取当前页面    \n    function getPageInstance() {\n    	var pages = getCurrentPages();\n    	return pages[pages.length - 1];\n    }\n    \n    exports.loginCheck = loginCheck;\n    \n以上，通用的过滤函数就写好了。在需要使用的页面引入该方法即可：\n\n    // pages/user/user.js\n    const filter = require(\'../../utils/filter\');\n    Page(filter.loginCheck({\n        // ...\n        onLoad: function (options) {\n           // ...\n        },\n        // ...\n    }));\n\n## 总结\n相比Vue.js官方提供的路由拦截功能，自己实现微信小程序的路由拦截还是存在一定的不足。比如：\n\n1. 微信小程序需要进行路由拦截的每个页面都需要引入，并包装一层，使用起来还是比较繁琐的。\n\n2. Vue.js是每次跳转到新的路由（页面）前进行处理，校验通过会跳转到新页面，不通过则直接跳转到登陆页面；而微信小程序这里，会先跳转到新页面，校验不通过会再次跳转到登陆页面。\n\n目前在微信小程序这方面如果有比较好的解决方案的话，可以相互交流一下。\n\n路由跳转拦截是一个非常常用的功能，希望后续微信小程序官方能给出一个比较好的官方解决方案。',2,'PUBLISHED','','2017-11-06 20:16:25',33);
insert  into `post`(`id`,`title`,`content`,`categoryId`,`status`,`poster`,`createTime`,`viewTotal`) values (15,'Vue.js开发一个全局调用的MessageBox组件','## 前言\n\n目前在开发个人博客项目中，一开始就没准备使用一些现在比较流行的UI库（毕竟是个人项目，多练练手还是好的），所以需要自己开发几个全局组件，这里以MessageBox为例记录下Vue.js如何开发全局组件。\n\n## 源码\n\n[Talk is cheap. Show me the code.](https://github.com/XNAL/don-blog-backManage/tree/master/src/components/MessageBox)\n<!-- more -->\n## 组件模板\n    // /src/components/MessageBox/index.vue\n    <template>\n        <div class=\"message-box\" v-show=\"isShowMessageBox\">\n        	<div class=\"mask\" @click=\"cancel\"></div>\n        	<div class=\"message-content\">\n            <svg class=\"icon\" aria-hidden=\"true\" @click=\"cancel\">\n              <use xlink:href=\"#icon-delete\"></use>\n            </svg>\n        		<h3 class=\"title\">{{ title }}</h3>\n        		<p class=\"content\">{{ content }}</p>\n            <div>\n              <input type=\"text\" v-model=\"inputValue\" v-if=\"isShowInput\" ref=\"input\">\n            </div>\n        		<div class=\"btn-group\">\n        			<button class=\"btn-default\" @click=\"cancel\" v-show=\"isShowCancelBtn\">{{ cancelBtnText }}</button>\n        			<button class=\"btn-primary btn-confirm\" @click=\"confirm\" v-show=\"isShowConfimrBtn\">{{ confirmBtnText }}</button>\n        		</div>\n        	</div>\n        </div>\n        </template>\n        \n        <script>\n        export default {\n          props: {\n            title: {\n              type: String,\n              default: \'标题\'\n            },\n            content: {\n              type: String,\n              default: \'这是弹框内容\'\n            },\n            isShowInput: false,\n            inputValue: \'\',\n            isShowCancelBtn: {\n              type: Boolean,\n              default: true\n            },\n            isShowConfimrBtn: {\n              type: Boolean,\n              default: true\n            },\n            cancelBtnText: {\n              type: String,\n              default: \'取消\'\n            },\n            confirmBtnText: {\n              type: String,\n              default: \'确定\'\n            }\n          },\n          data () {\n            return {\n              isShowMessageBox: false,\n              resolve: \'\',\n              reject: \'\',\n              promise: \'\' // 保存promise对象\n            };\n          },\n          methods: {\n            // 确定,将promise断定为resolve状态\n            confirm: function () {\n              this.isShowMessageBox = false;\n              if (this.isShowInput) {\n                this.resolve(this.inputValue);\n              } else {\n                this.resolve(\'confirm\');\n              }\n              this.remove();\n            },\n            // 取消,将promise断定为reject状态\n            cancel: function () {\n              this.isShowMessageBox = false;\n              this.reject(\'cancel\');\n              this.remove();\n            },\n            // 弹出messageBox,并创建promise对象\n            showMsgBox: function () {\n              this.isShowMessageBox = true;\n              this.promise = new Promise((resolve, reject) => {\n                this.resolve = resolve;\n                this.reject = reject;\n              });\n              // 返回promise对象\n              return this.promise;\n            },\n            remove: function () {\n              setTimeout(() => {\n                this.destroy();\n              }, 300);\n            },\n            destroy: function () {\n              this.$destroy();\n              document.body.removeChild(this.$el);\n            }\n          }\n        };\n        </script>\n        <style lang=\"scss\" scoped>\n        // 此处省略 ...\n        </style>\n        \n## 给组件添加全局功能\n\nvue.js官方文档中有[开发插件的介绍](https://cn.vuejs.org/v2/guide/plugins.html)。具体实现代码如下：\n\n    // /src/components/MessageBox/index.js\n    \n    import msgboxVue from \'./index.vue\';    \n    // 定义插件对象\n    const MessageBox = {};\n    // vue的install方法，用于定义vue插件\n    MessageBox.install = function (Vue, options) {\n      const MessageBoxInstance = Vue.extend(msgboxVue);\n      let currentMsg;\n      const initInstance = () => {\n        // 实例化vue实例\n        currentMsg = new MessageBoxInstance();\n        let msgBoxEl = currentMsg.$mount().$el;\n        document.body.appendChild(msgBoxEl);\n      };\n      // 在Vue的原型上添加实例方法，以全局调用\n      Vue.prototype.$msgBox = {\n        showMsgBox (options) {\n          if (!currentMsg) {\n            initInstance();\n          }\n          if (typeof options === \'string\') {\n            currentMsg.content = options;\n          } else if (typeof options === \'object\') {\n            Object.assign(currentMsg, options);\n          }\n          return currentMsg.showMsgBox()\n            .then(val => {\n              currentMsg = null;\n              return Promise.resolve(val);\n            })\n            .catch(err => {\n              currentMsg = null;\n              return Promise.reject(err);\n            });\n        }\n      };\n    };\n    export default MessageBox;\n\n## 全局使用\n    \n    // src/main.js\n    import MessageBox from \'./components/MessageBox/index\';\n    Vue.use(MessageBox);\n\n## 页面调用\n\n按照之前定义好的方法，可以在各个页面中愉快的调用该组件了。\n\n    this.$msgBox.showMsgBox({\n        title: \'添加分类\',\n        content: \'请填写分类名称\',\n        isShowInput: true\n    }).then(async (val) => {\n        // ...        \n    }).catch(() => {\n        // ...\n    });    \n    \n## 最后来张效果图\n![messagebox效果图](/images/dialog/messagebox.png)\n',2,'PUBLISHED','','2017-11-18 00:18:26',39);
insert  into `post`(`id`,`title`,`content`,`categoryId`,`status`,`poster`,`createTime`,`viewTotal`) values (16,'个人博客开发系列：Vue.js + Koa.js项目中使用JWT认证','## 前言\n\n> JWT(JSON Web Token)，是为了在网络环境间传递声明而执行的一种基于JSON的开放标准（RFC 7519）。\n\n\n\n更多的介绍和说明，以及各种原理，我在此就不多赘诉了。JWT不是一个新鲜的东西，网上相关的介绍已经非常多了。不是很了解的可以在网上搜索一下相关信息。\n\n\n## 源码\n\n[Talk is cheap. Show me the code.](https://github.com/XNAL/don-blog-backManage/tree/master/server/middlreware)\n\n<!-- more -->\n## 工作流程\n\nJWT本质来说是一个token。在前后端进行HTTP连接时来进行相应的验证。\n\n1. 博客的后台管理系统发起登录请求，后端服务器校验成功之后，生成JWT认证信息；\n2. 前端接收到JWT后进行存储；\n3. 前端在之后每次接口调用发起HTTP请求时，会将JWT放到HTTP的headers参数里的authorization中一起发送给后端；\n4. 后端接收到请求时会根据JWT中的信息来校验当前发起HTTP请求的用户是否是具有访问权限的，有访问权限时则交给服务器继续处理，没有时则直接返回401错误。\n\n\n## 实现过程\n\n#### 1. 登录成功生成JWT\n\n> 说明：以下代码只保留了核心代码，详细代码可在对应文件中查看，下同。\n\n```javascript\n// /server/api/admin/admin.controller.js\nconst jwt = require(\'jsonwebtoken\');\nconst config = require(\'../../config/config\');\n\nexports.login = async(ctx) => {\n  // ...\n  if (hashedPassword === hashPassword) {\n    // ...\n    // 用户token\n    const userToken = {\n      name: userName,\n      id: results[0].id\n    };\n    // 签发token\n    const token = jwt.sign(userToken, config.tokenSecret, { expiresIn: \'2h\' });\n    // ...\n  }\n  // ...\n}\n```\n\n\n\n#### 2. 添加中间件校验JWT\n\n```javascript\n// /server/middlreware/tokenError.js\nconst jwt = require(\'jsonwebtoken\');\nconst config = require(\'../config/config\');\nconst util = require(\'util\');\nconst verify = util.promisify(jwt.verify);\n\n/**\n * 判断token是否可用\n */\nmodule.exports = function () {\n  return async function (ctx, next) {\n    try {\n      // 获取jwt\n      const token = ctx.header.authorization; \n      if (token) {\n        try {\n          // 解密payload，获取用户名和ID\n          let payload = await verify(token.split(\' \')[1], config.tokenSecret);\n          ctx.user = {\n            name: payload.name,\n            id: payload.id\n          };\n        } catch (err) {\n          console.log(\'token verify fail: \', err)\n        }\n      }\n      await next();\n    } catch (err) {\n      if (err.status === 401) {\n        ctx.status = 401;\n        ctx.body = {\n          success: 0,\n          message: \'认证失败\'\n        };\n      } else {\n        err.status = 404;\n        ctx.body = {\n          success: 0,\n          message: \'404\'\n        };\n      }\n    }\n  }\n}\n```\n\n\n\n#### 3. Koa.js中添加JWT处理\n\n此处在开发时需要过滤掉登录接口(login)，否则会导致JWT验证永远失败。\n\n```javascript\n// /server/config/koa.js\nconst jwt = require(\'koa-jwt\');\nconst tokenError = require(\'../middlreware/tokenError\');\n// ...\n\nconst app = new Koa();\n\napp.use(tokenError());\napp.use(bodyParser());\napp.use(koaJson());\napp.use(resource(path.join(config.root, config.appPath)));\n\napp.use(jwt({\n  secret: config.tokenSecret\n}).unless({\n  path: [/^\\/backapi\\/admin\\/login/, /^\\/blogapi\\//]\n}));\n\nmodule.exports = app;\n\n```\n\n\n\n#### 4.前端处理\n\n> 前端开发使用的是Vue.js，发送HTTP请求使用的是axios。\n\n1. 登录成功之后将JWT存储到localStorage中（可根据个人需要存储，我个人是比较喜欢存储到localStorage中）。\n\n   ```javascript\n   methods: {\n       login: async function () {\n         // ...\n\n         let res = await api.login(this.userName, this.password);\n         if (res.success === 1) {\n           this.errMsg = \'\';\n           localStorage.setItem(\'DON_BLOG_TOKEN\', res.token);\n           this.$router.push({ path: \'/postlist\' });\n         } else {\n           this.errMsg = res.message;\n         }\n       }\n     }\n   ```\n\n   ​\n\n2. Vue.js的router（路由）跳转前校验JWT是否存在，不存在则跳转到登录页面。\n\n   ```javascript\n   // /src/router/index.js\n   router.beforeEach((to, from, next) => {\n     if (to.meta.requireAuth) {\n       const token = localStorage.getItem(\'DON_BLOG_TOKEN\');\n       if (token && token !== \'null\') {\n         next();\n       } else {\n         next(\'/login\');\n       }\n     } else {\n       next();\n     }\n   });\n   ```\n\n   ​\n\n3. axios拦截器中给HTTP统一添加Authorization信息\n\n   ```javascript\n   // /src/fetch/fetch.js\n   axios.interceptors.request.use(\n     config => {\n       const token = localStorage.getItem(\'DON_BLOG_TOKEN\');\n       if (token) {\n         // Bearer是JWT的认证头部信息\n         config.headers.common[\'Authorization\'] = \'Bearer \' + token;\n       }\n       return config;\n     },\n     error => {\n       return Promise.reject(error);\n     }\n   );\n   ```\n\n   ​\n\n4. axios拦截器在接收到HTTP返回时统一处理返回状态\n\n   ```javascript\n   // /src/main.js\n   axios.interceptors.response.use(\n     response => {\n       return response;\n     },\n     error => {\n       if (error.response.status === 401) {\n         Vue.prototype.$msgBox.showMsgBox({\n           title: \'错误提示\',\n           content: \'您的登录信息已失效，请重新登录\',\n           isShowCancelBtn: false\n         }).then((val) => {\n           router.push(\'/login\');\n         }).catch(() => {\n           console.log(\'cancel\');\n         });\n       } else {\n         Vue.prototype.$message.showMessage({\n           type: \'error\',\n           content: \'系统出现错误\'\n         });\n       }\n       return Promise.reject(error);\n     }\n   );\n   ```\n\n\n\n## 总结\n\n到这里整个流程就走完了。当然单纯的JWT并不是说绝对安全的，不过对于一个个人博客系统的认证来说还是足够的。\n\n最后打个小广告。目前正在开发新版的个人博客中，包括[前端](https://github.com/XNAL/don-blog)和[后端](https://github.com/XNAL/don-blog-backManage)两部分，都已在GitHub上开源，目前在逐步完善功能中。欢迎感兴趣的同学fork和star。',1,'PUBLISHED','','2017-12-02 19:20:03',48);
insert  into `post`(`id`,`title`,`content`,`categoryId`,`status`,`poster`,`createTime`,`viewTotal`) values (17,'个人博客开发系列：前台博客页面开发部署完成','## 前言\n\n> 之前使用JS + HTML5 + CSS3 + Node.js + Express.js + Mongodb开发过一个博客网站，也部署了一段时间，但当时刚开始搞前端，写的不是很满意。后来就废弃了。今年又使用Hexo + GitHub Pages部署了一个博客，但自由度太低。所以最后还是决定重新写一个博客。\n\n\n\n目前前台博客页面已基本开发完成（评论功能待开发，在考虑方案中），后台管理页面也基本开发完成（首页统计图表和一些优化待开发，暂时需要统计的数据还不多，也在考虑统计维度中）。\n\n\n\n此篇文章先介绍下前台博客页面。\n\n<!-- more -->\n\n## 技术栈\n\nVue.js + Nuxt.js  + SCSS + ES6/7 + Node.js + Koa.js + mySql + Redis\n\n\n\n## 源码\n\n[Talk is cheap. Show me the code.](https://github.com/XNAL/don-blog)\n\n## 访问地址\n\n[访问地址：www.tdon.site](http://www.tdon.site)\n\n扫码访问：\n![二维码](/images/blog/qrcode.png)\n## 效果图\n\n#### 首页\n\n![首页](/images/blog/index.jpg)\n\n\n#### 归档\n\n![归档](/images/blog/archive.jpg)\n\n\n#### 实验室项目\n![实验室项目](/images/blog/laboratory.jpg)\n\n\n#### 自适应手机端首页\n![自适应手机端首页](/images/blog/phone-index.jpg)\n\n#### 自适应手机端目录\n![自适应手机端目录](/images/blog/phone-menu.jpg)\n\n## 总结\n\n1. 整个技术栈对我来说Nuxt.js算是第一次接触，跟Vue.js的单页面应用的方式还是有点区别的，不过多看看文档和多搜索下问题不大。\n2. 目前应该只能算是1.0版本，自己也有不少想法，但目前工作以及其他事要忙，只能后续会逐步迭代开发了。也欢迎大家针对博客提出一些意见或者建议。\n3. 最后还是得求一波star和fork的。\n',1,'PUBLISHED','','2017-12-16 21:17:51',36);
insert  into `post`(`id`,`title`,`content`,`categoryId`,`status`,`poster`,`createTime`,`viewTotal`) values (18,'个人博客开发系列：文章实时保存','## 前言\n\n一般用来写东西的网站都会有一个编辑实时保存的功能。对于使用者来说是一个非常实用的功能。作为一个个人博客来说，虽然用处没那么明显，但是还是想实现一下这个功能，就当是练练手吧。\n\n\n\n## 实现思路\n\n1. 使用`WebSocket`来进行浏览器与服务器的实时通信；\n2. 服务端使用`Redis`来缓存实时编辑的文章（编辑时文章改动频繁，频繁读写数据库操作不是个好的方案）；\n3. 服务端使用定时任务（如每天凌晨3点），将`Redis`缓存的数据存储到`MySQL`数据库中；\n4. 浏览器端初次进入新增文章页面时，使用`WebSocket`从服务端获取数据（先从`Redis`中查找，如果没有则再从`MySQL`数据库中查找）；\n5. 浏览器端初次进入编辑文章页面时，不需要从服务端获取数据；\n6. 使用`Vue.js`的watch来监听文章的变化，变化时使用`WebSocket`向服务端传送数据。\n7. 文章保存时清空`Redis`和`MySQL`中实时保存的数据。\n\n\n## 源码\n\n[Talk is cheap. Show me the code.](https://github.com/XNAL/don-blog-backManage/blob/master/server/util/draft-socketio.js)\n\n\n\n## 说明\n\n> 1. 本功能只是个人博客后台使用，没有多账户体系，所以`Redis`和`MySQL`中都是保存一条记录。如果需要按不同用户来保存的话，需要自行开发。\n>\n>\n> 1. 代码比较多，具体的代码就不贴了，有兴趣的可以去[`我的GitHub`](https://github.com/XNAL)上查看源码。这里只说明一下各个文件中代码的用处。\n\n\n\n#### 1. /[server](https://github.com/XNAL/don-blog-backManage/tree/master/server)/[util](https://github.com/XNAL/don-blog-backManage/tree/master/server/util)/draft-socketio.js\n\n服务端`WebSocket`服务，使用了`socket.io`库。\n\n\n\n#### 2./[server](https://github.com/XNAL/don-blog-backManage/tree/master/server)/[util](https://github.com/XNAL/don-blog-backManage/tree/master/server/util)/draft-redis.js\n\n`Redis`的`set`和`get`的公共方法。\n\n\n\n#### 3./[server](https://github.com/XNAL/don-blog-backManage/tree/master/server)/[util](https://github.com/XNAL/don-blog-backManage/tree/master/server/util)/redis-mysql.js\n\n- `redisToMysqlTask`：定时同步`Redis`数据到`MySQL`数据的方法，使用了`node-schedule`库。\n- `getDraftPostFromMysql`: `Redis`中不存在数据时，在`MySQL`中查询数据。\n- `clearDraftPostOfMysql`：从`MySQL`中删除数据（文章保存后操作）。\n\n\n\n#### 4. /src/main.js\n\n浏览器端先引入`socket.io`，使用了`vue-socket.io`和`socket.io-client`库。\n\n```javascript\nimport VueSocketio from \'vue-socket.io\';\nimport socketio from \'socket.io-client\';\n\nVue.use(VueSocketio, socketio(\'http://localhost:9000\', {\n  path: \'/testsocketiopath\'\n}));\n```\n\n\n\n#### 5./[src](https://github.com/XNAL/don-blog-backManage/tree/master/src)/[pages](https://github.com/XNAL/don-blog-backManage/tree/master/src/pages)/Edit.vue\n\n使用`WebSocket`从服务端获取数据，并实时将数据传输到服务端进行保存。\n\n\n\n## 总结\n\n1. 整个功能其实就是`WebSocket`、`Redis`和`MySQL`的使用，这几个之前都用过，所以开发起来还是比较容易。最重要的是要先想好解决方案。\n2. 最后照例求一下[`fork`](https://github.com/XNAL)和[`star`](https://github.com/XNAL)。',2,'PUBLISHED','','2017-12-24 18:06:39',27);

/*Table structure for table `post_tag` */

DROP TABLE IF EXISTS `post_tag`;

CREATE TABLE `post_tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `postId` int(11) NOT NULL COMMENT '文章表主键',
  `tagId` int(11) NOT NULL COMMENT '标签表主键',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=95 DEFAULT CHARSET=utf8 COMMENT='文章-标签对应表';

/*Data for the table `post_tag` */

insert  into `post_tag`(`id`,`postId`,`tagId`) values (11,7,13);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (23,15,1);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (24,15,26);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (25,15,27);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (26,16,1);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (27,16,28);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (28,16,29);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (29,16,30);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (30,14,1);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (31,14,13);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (32,14,25);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (36,2,4);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (37,2,5);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (38,2,1);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (39,3,8);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (40,3,6);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (41,3,7);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (42,6,1);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (43,6,11);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (44,6,12);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (49,4,6);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (50,4,9);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (56,17,1);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (57,17,31);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (58,17,28);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (59,17,6);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (60,17,30);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (74,1,1);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (75,1,2);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (76,1,3);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (77,5,1);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (78,5,6);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (79,5,10);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (80,5,9);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (81,19,1);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (82,20,2);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (83,21,2);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (84,21,6);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (85,22,2);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (86,22,6);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (87,23,2);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (88,24,1);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (89,25,1);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (90,18,1);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (91,18,32);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (92,18,33);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (93,18,34);
insert  into `post_tag`(`id`,`postId`,`tagId`) values (94,18,35);

/*Table structure for table `tag` */

DROP TABLE IF EXISTS `tag`;

CREATE TABLE `tag` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) DEFAULT NULL COMMENT '标签名称',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=36 DEFAULT CHARSET=utf8 COMMENT='标签表';

/*Data for the table `tag` */

insert  into `tag`(`id`,`name`) values (1,'Vue.js');
insert  into `tag`(`id`,`name`) values (2,'Vuex');
insert  into `tag`(`id`,`name`) values (3,'webapp');
insert  into `tag`(`id`,`name`) values (4,'模态框');
insert  into `tag`(`id`,`name`) values (5,'promise');
insert  into `tag`(`id`,`name`) values (6,'Node.js');
insert  into `tag`(`id`,`name`) values (7,'Canvas');
insert  into `tag`(`id`,`name`) values (8,'Socket.IO');
insert  into `tag`(`id`,`name`) values (9,'网页爬虫');
insert  into `tag`(`id`,`name`) values (10,'GitHub');
insert  into `tag`(`id`,`name`) values (11,'nginx');
insert  into `tag`(`id`,`name`) values (12,'域名');
insert  into `tag`(`id`,`name`) values (13,'微信小程序');
insert  into `tag`(`id`,`name`) values (25,'路由');
insert  into `tag`(`id`,`name`) values (26,'组件化');
insert  into `tag`(`id`,`name`) values (27,'UI');
insert  into `tag`(`id`,`name`) values (28,'Koa.js');
insert  into `tag`(`id`,`name`) values (29,'JWT');
insert  into `tag`(`id`,`name`) values (30,'博客');
insert  into `tag`(`id`,`name`) values (31,'Nuxt.js');
insert  into `tag`(`id`,`name`) values (32,'WebSocket');
insert  into `tag`(`id`,`name`) values (33,'Redis');
insert  into `tag`(`id`,`name`) values (34,'MySQL');
insert  into `tag`(`id`,`name`) values (35,'实时保存');

/*Table structure for table `user` */

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `userName` varchar(50) DEFAULT NULL COMMENT '用户名',
  `hashedPassword` varchar(1024) DEFAULT NULL COMMENT '加密后的密码',
  `salt` varchar(128) DEFAULT NULL COMMENT '加密的盐',
  `avatar` varchar(500) DEFAULT NULL COMMENT '用户头像',
  `role` enum('ADMIN','GUEST') DEFAULT NULL COMMENT '用户角色（ADMIN:管理员，GUEST:游客）',
  `createTime` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=42 DEFAULT CHARSET=utf8 COMMENT='用户表';

/*Data for the table `user` */

insert  into `user`(`id`,`userName`,`hashedPassword`,`salt`,`avatar`,`role`,`createTime`) values (41,'admin','F4jEAsk08C9RJ2zpMbwOqDCnJso1SqIYmakqvNRR/nL/z6mXOynAi2+G5YoTRs8OzaFsqgnwUaK6NQWx0oqrOQ==','s3z8t0ZimfJ33ECgI3L1Xw==',NULL,'ADMIN','2018-01-01 18:36:22');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
